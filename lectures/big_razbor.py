""" Типы данных в python """
# 1. Immutable - неизменяемые
# str, int, float, tuple, frozenset, bool, None

# 2. Mutable - изменяемые
# list, set, dict


""" Numbers """
# Numbers - неизменяемый тип данных предназначенный для хранения числовых значений и проведения над ними арифметических вычислений

# numbers --> int (целочисленный)
#         --> float (вещественные, дробные, с плавающей точкой)
#         --> decimal (дробные но более точные)
#         --> complex (комплексные 5 + 6j - 3i)
#         --> long (огромные числа)

"""int, float"""
# abs(int)
# abs(float)
# abs -> возвращает модуль числа (из отрицательного в положительное)

# pow(num, degree, remainder) -> (num ** degree) % remainder
# pow(int, int) -> возводит первое число в степень второго
# pow(int, int, int) -> возводит первое число в степень второго и находит остаток от деления результата на третье число

# divmod(num1, num2) -> (num1 // num2), (num1 % num2)
# divmod(int, int) -> возвращает 2 результата: 
# 1. частное этих чисел
# 2. остаток от деления этих чисел

""" Strings """
# строка - неизменяемый тип данных, который представляет собой упорядоченную последовательность символов, заключенных в двойные или одинарные кавычки 

# Синтаксис
'hello'
"world"
# "hello" * 3 -> hellohellohello -> дублирование строки

'''
многострочная строка с одинарными кавычками
'''
"""
многострочная строка с двойными кавычками
"""
# индексы - нумерация символов в упорядоченной последовательности (интексация начинается с 0)
# "h e l l o   w o r l d" 
#  0 1 2 3 4 5 6 7 8 9 10
#               ... -2 -1  

"""обращение по индексу"""
# string = "some string"
# string[index]

# срезы - это часть строки (подстрока)
# string = "some string"
# string[start : end : (step)]
# start -> начало среза (какой символ будет первый в подстроке)
# end -> конец среза (до какого индекса будет срез, символ под этим индексом не включается)
# step -> шаг среза (через сколько индексов будет следущий символ)
# start < end

# dir(obj) -> список всех методов у объекта

"""Bool"""
# bool - логический тип данных, с двумя значениями
# True - правда (1)
# False - ложь (0)
# bool([3, 4 ,5]) -> True
# bool([]) -> False
# bool([[]]) -> True


"""Lists"""
# списки - изменяемый, упорядоченный тип данных, который хранит последовательность элементов. Элементами списка могут быть абсолютно любые типы данных, в том числе и списки. Литералы списков кватратные скобки []

# способы создания списков
# list1 = [1, 'str', 3.4, (7.4), ["str", 6]]
# list2 = list((1, 2, 4, 6, 7))
# list3 = [5] * 6 -> [5, 5, 5, 5, 5, 5]
# list4 = ["a"] * 5 -> ['a', 'a', 'a', 'a', 'a']

# list5 = list( range(10) )
"""range(start, end, step) - это функция, которая создает последовательность чисел"""
# list(range(5)) -> [0, 1, 2 ,3, 4]
# list(range(2, 8)) -> [2, 3, 4, 5, 6, 7]
# list(range(4, 10, 2)) -> [4, 6, 8]

"""len"""
# len(obj) - функция, возвращающая длину объекта
# len( ["hello"] ) -> 1
# len( "hello" ) -> 5

""" Tuple """
# кортеж - неизменяемый, упорядоченный тип данных, который хранит последовательность элементов. Элементами кортежа могут быть абсолютно любые типы данных, в том числе и списки и кортежи. Литералы кортежа круглые скобки ()

# синтаксис
# (1, 2, 3, 4)
# (3) - это int, (3,) - а это tuple
# a = (3) -> 3  (int)
# b = (3, ) -> (3, )  (tuple)


""" Set """
# множество - изменяемый, неупорядоченный тип данных, который хранит в себе только уникальные неизменяемые значения
# print({1, 0, True, False}) -> 0, 1   (0 = False), (1 = True)
# print({True, False, 2, 0}) -> {True, False, 2} 
# print({True, False, 2, 0, None, []}) -> Error
# print({True, False, 2, 0, None, ()}) -> {True, False, 2, None, ()}

# синтаксис
# {1, 2, 3, 4, 65}
# set(iterable)

"""Frozenset"""
# неизменяемое множество неупорядоченный тип данных, который хранит в себе только уникальные неизменяемые значения
# синтаксис
# frozenset(itarable)


"""Dictionary"""
# Словарь - изменяемый, неупорядоченный тип данных, в котором хранятся пары в виде ключ - значение.
# Ключ в словаре - любой неизменяемый тип данных. Каждый ключ уникальный
# Значение в словаре - любой тип данных
# Ключ от значения отделяется двоеточием
# Пары отделяются запятыми

# синтаксис
# a = {"key": "value", 5: ["hello"]}
# dict(iterable)
# dict( [("key1", "value1"), ("key2", "value2")] )
# for i in a:
    # print(a[i])      # выводит значения
# for i in a:
    # print(i)         # выводит ключи
"""None"""
# None - неизменяемый тип данных, который используется для обозначения пустого значения или отсутствия значения














"""Conditions"""
# Условия - оператор, который позволяет нам выполнять или не выполнять какой-то кусочек кода, который находиться в теле условия 

# Синтаксис
# if условие:
#     тело

# if True:
#     print("Условие верное")

# Также мы  можем создавать конструкции из 

# if условие:
#     тело1
# elif условие:
#     тело2
# else:
#     тело3

# Если в первом if условие выдало True, то выполнится тело1
# Если первое if условие выдало False, то выполнится второе условие elif
# Если второе elif условие выдало True, то выполнится тело2
# Если второе elif условие выдало False, то выполнится тело3

# if и else в конструкции может быть использовано только 1 раз, elif может быть много


"""Тернарные условия"""
# т.у - это условие, написанное в одну строку

# синтаксиз
# тело1 if условие else тело2
# print("условие верное") if условие else print("условие не верное")   условие - True и False





"""Loops"""
# Цикл - это блок кода, который будет выполнятся несколько раз, каждый круг цикла называется - итерация

# break - инструкция, которая немедленно прерывает работу цикла 
# continue - инструкция, которая немедленно переходит к следующей итерации

"""For"""
# for - цикл, который производит итерации над последовательностью (list, dict, set, str, tuple)
# В цикле for мы можем выполнять различные операции над каждым элементом последовательности

# синтаксис
# for элемент in последовательность:               # элемент = переменная
#     какие-то действия


"""While"""
# while - цикл, который производит какие-то действия пока условие будет True 

# синтаксис
# while условие:
#         какие-то действия

"""enumerate(последовательность)"""

"""Comprehensions"""
# Генератор последовательности - специальная конструкция, с посмощью которой можно создавать последовательности

# синтаксис

# действие for элемент in последовательность if  условие          # if - это фильтр 

# [x for x in range(1, 11) if x % 2 == 0]

# ["четное" if x % 2 == 0 else "нечетное" for x in range(1, 11)] 


# Dict comprehension
# Для dict comprehension в действии должна быть пара (ключ: значение)
# {x:x ** 2 for x in range(1, 11) if x % 2 == 0}

# init_dict  = {"key": "value", "key2": "value2"}
# res = {v:k for k, v in init_dict.items()}



"""Try-except"""
# try-except - конструкция, для обработки исключений и ошибок
# синтаксические ошибки мы не можем обрабатывать

# синтаксис
# try:
#     код, который может вызвать ошибку
# except Исключение:
#     код, который работает если ошибка вышла 
# else:
#     код, который работает, если ошибка не вышла
# finally:
#     код, который работает в любом случае

# try:
#     raise Exception()
# except:
#     print("exception catched")
# finally:
#     print('finally')












"""Functions"""
# Функция - именованный блок кода, выполняющий какие-то действия и возвращающий какой-то результат. Мы можем вызывать функцию, обращаясь к ней по имени и используя круглые скобочки.
# код который написан внутри функции будет работать только при вызове функции
# функции могут принимать данные(аргументы)

# параметры функции - локальные переменные, которым присваиваются значения при вызове функции

# аргументы функции - конкретные значения, которые мы передаем параметры функции

# def - инструкция, с помощью которой определяется функция
# return - инструкция, с помощью которой функция возвращает результат, если ее не прописать, по дефолту возвращается значение None
# * - это распаковка возвращает tuple (цикл for)
# a = b = c = 5 -> a5, b5, c5
# a, b, c = 5 ->  Error

"""Types of arguments"""
# позиционные аргументы
# именованные аргументы
# параметры с дефолтом
# необязательные аргументы (*)
# ключевые аргументы (**) 

# def func(позиционные, с_дефолтом, *args, **kwargs):
#     args - tuple
#     kwargs - dict

# func(позиционные, параметр=значение, необязательные_аргументы, ключ=значение)



"""Встроенные функции"""

"""map"""
# map - функция, которая выполняет действия над каждым элементом последовательности и возвращает генератор новой последовательности
# принимает 2 аргумента:
# 1 - функция
# 2- последовательность

# map - сокращенная for

# list_ = ["1", "2", "3", "4", "5"]
# print( [int(x) for x in list_] )
# print(list(map(int, list_)))

# синтаксис
# map(int, ["1", "2", "3"])

# def myfunc(elem):
#     return elem.upper()

# map(myfunc, ["hello", "world"])
# ["HELLO", "WORLD"]


"""filter"""
# filter - функция, которая возвращает последовательность из элементов, соответствующих условию
# она принимает 2 аргумента
# 1 - функция, которая возвращает булевое значение и принимает 1 аргумент
# если True, то добавляется
# 2- последовательность

# синтаксис
# def myfunc(elem):
#     return elem.isalpha()

# print(list(filter(myfunc, ['1', '2', '3', 'd', 't'])))
# ["d", "t"]

# def myfunc(elem):
#     if elem > 0:
#         return True
#     return False

# list(filter(myfunc, [-1, 4, -3, 0, 6, 30, -2]))
# [4, 6, 30]
# list(map(myfunc, [-1, 4, -3, 0, 6, 30, -2]))
# [False, True, False, False, True, True, False]



"""Zip"""
# zip - функция, которая объединяет элементы из нескольких последовательностей под индексам в tuple, т.е все элементы под индексом 0 в первый tuple, все элементы под элементы под индексом 1 во втором tuple и т.д


# list1 = [1, 2, 3, 4, 5]
# list2 = ["a", "b", "c", "d"]
# list3 = [1.0, 2.0, 3.0]
# print(list( zip(list1, list2, list3) ))
# [(1, 'a', 1.0), (2, 'b', 2.0), (3, 'c', 3.0)]



"""Reduce"""
# reduce - функция, которую надо импортировать из библиотеки functools
# from functools import reduce
# она принимает 2 аргумента:
# 1. функция, которая принимает 2 аргумента и возвращает булевое значение
# 2. последовательность
# функция reduce берет из последовательности 2 элемента, отправляет их в функцию, результат и следующий элемент из последовательности снова отправляет в функцию и т.д

# синтаксис

# def myfunc(x, y):
#     return x if len(x) >= len(y) else y

# reduce(myfunc, ["hello", "world", "длинная строка", "makers"])
# "длинная строка"

# list_ = [5, 4, 3, 2]
# def f(x, y):
#     return x * y      # if x < y else y

# print(reduce(f, list_))



"""Lambda"""
# lambda - анонимная функция (нет имени, одноразовая) 

# синтаксис
# lambda переменные: действие которое нужно вернуть

# myfunc = lambda x, y: (x ** 2, y ** 2)
# print(myfunc(5, 6))


"""all"""
# возвращает либо True или False, если в последовательности есть хотя бы один False то послед будет False, если в послед все будет True то послед будет True
"""any"""
# возвращает True, если в последовательности есть хотя один True то послед будет True 






"""задание 3"""
# num = int(input())
# list1 = list(str(num))
# if list1 == list(sorted(list1, reverse=True)):
#     print()


"""задание 4"""
# diap = list(range(10000, 100000, 2))
# res = []
# for num in diap:
#     if int(str(num)[2]) % 2 != 0:
#         if sum(map(int, str(num))) % 4 == 0:
#             res.append(num)
# print(res)

"""задание 5"""
# num = input()
# max_index = num.index(max(num))
# min_index = num.index(min(num))

# res = list(num)
# res[max_index] = min(num)
# res[min_index] = max(num)
# print(res)

"""задание 6"""
# geo_logs = [
#     {"visits1": ["Deli", "India"]},
#     {"visits2": ["Vladimir","Rossia"]},
#     {"visits3": ["Kursk", "Rossia"]}

# ]

# res = []
# for log in geo_logs:
#     if list(log.values())[0][-1] == "Rossia":
#         res.append(log)
# for log in geo_logs:
#     if "Rossia" in list(log.values())[0]:
#         res.append(log)

# print(res)
        
"""задание 9"""
# correct = {k: 31 if k % 2 == 0 else 30 for k in range(1, 13)}
# correct[2] = 28
# day, m, y = map(int, input().split())
# if not m in range(1, 13):
#     print("no")
# else:
#     if day in range(1, correct[m] + 1):
#         print("yes")
#     else:
#         print("no")